                                                                   SORTING
___________________________________________________________________________________________________________________________________________

ğŸ” BUBBLE SORT : Repeatedly swap adjacent elements if they are in the wrong order.
Time Complexity : O(n^2)
What to say :  outer loop (int i=0; i<arr.length-1); i++);
               Inner loop ( int j=0; j<arr.length-i-1; j++;
               comparision : arr[j] > arr[j+1] => swap(arr,j,j+1);
-----------------------------

(1) Sort an array using bubble sort ?
intput :
int [] arr = {5, 1, 4, 2, 8};
output : 1, 2, 4, 5, 8

(2) Sort in descending order ?
intput :
int [] arr = {3, 7, 2};
output : 7, 3, 2

(3) Sort array with duplicates ?
intput :
int [] arr = {4, 5, 4, 2};
output : 2, 4, 4, 5

(4) Sort already sorted array ?
intput :
int [] arr = {1, 2, 3, 4};
output : 1, 2, 3, 4

(5) Sort with one element ?
intput :
int [] arr = {10};
output : 10



ğŸªœ INSERTION SORT : this idea comes from playing card, Take one number at a time and insert it into the correct position in the sorted part.
Time Complexity : O(n^2)
What it say : Outer Loop : for (int i=1; i<arr.length; i++){
                                    int curr= arr[i];
                                    int prev= i-1;
              Inner loop :  while (prev >=0 && arr[prev]>curr){
                                   arr[prev+1]=arr[prev];
                                     prev--;
                                  }
                                   arr[prev+1]= curr;
                                   }
-----------------------------------------

(1) Sort an array?
intput :
int [] arr = {12, 11, 13, 5, 6};
output : 5, 6, 11, 12, 13

(2) Sort nearly sorted array ?
intput :
int [] arr = {1, 2, 4, 3, 5};
output : 1, 2, 3, 4, 5

(3) Sort string as character array ?
input : 
char [] arr = {'d', 'b', 'a'};
output : 'a', 'b', 'd'

(4) Sort array with 1 element ?
intput :
int [] arr = {9};
output : 9

(5) Sort with mix numbers ?
intput :
int [] arr = {3, -1, 2, 0};
output : -1, 0, 2, 3


ğŸ¯ SELECTION SORT : it is opposite of bubble sort, in it, we assume our array into 2 part one sorted and another unsorted then we Find the smallest number
from unsorted and move it to the sorted/front,again and again. first time whole array assume unsorted and find smallest
Time Complexity : O(n^2)
What to say : Outer Loop : for (int i=0; i<arr.length-1; i++);
               int smallestIndx = i;
               Inner Loop : for (int j=i+1; j<arr.length; j++)
               comprasion : if(arr[j] <arr[smallestIndex]){
                              smallestIndex=j; } } -> then swap (arr, i, smallestIndx);
---------------------------------------

(1) Sort an array using selection sort?
intput :
int [] arr = {64, 25, 12, 22, 11};
output : 11, 12, 22, 25, 64

(2) Sort descending ?
intput :
int [] arr = {5, 3, 6};
output : 6, 5, 3

(3) Sort with negative numbers ?
intput :
int [] arr = {-1, 3, -2, 0};
output : -2, -1, 0, 3

(4) Sort repeated elements ?
intput :
int [] arr = {2, 2, 1, 1};
output : 1, 1, 2, 2

(5) Sort array with 0s and 1s ?
intput :
int [] arr = {0, 1, 0, 1, 1};
output : 0, 0, 1, 1, 1


ğŸ”€ MERGE SORT : Keep dividing the array into halves, sort them, and then merge them back together.
---------------------

âš¡ QUICK SORT : Pick a number (pivot), put smaller numbers on left and bigger on right, then repeat for both sides
-------------------
