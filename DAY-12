(1) Count the Digits of a number lets say number is : 4567 ?
Steps to solve :
           - Take a number â†’ say num = 4567
           - Initialize a counter â†’ count = 0
           - Repeat while num > 0:
                    - Remove the last digit using num = num / 10
                    - Increase the counter â†’ count++
           - When the loop finishes, count will have the total number of digits.

(2) Digit Count using Logarithm ?
int v = (int) Math.floor(Math.log10(num))+1;

(3) Check if a Number is armstrong or not. ?
ğŸ‘‰ Short Definition:
A number is called an Armstrong number if the sum of each of its digits raised to the power of total digits equals the number itself.
Example: Letâ€™s take 153
                  â†’ It has 3 digits                 
                  â†’ So we do:  1Â³ + 5Â³ + 3Â³ = 1 + 125 + 27 = 153
ğŸŒŸ Properties of ArmStrong number :
                   - All single-digit numbers (0â€“9) are Armstrong numbers.
                       ğŸ‘‰ Because for example: 5 = 5Â¹ âœ…
                   - Permutations of an Armstrong number are not always Armstrong
                       âŒ (e.g., 153 is Armstrong but 531 is not!)
                   - Armstrong numbers are not always palindromes.
                     âŒ For example, 153 â‰  351 , Only a few are plindrome also (like 1, 0, to 9.).
                   - The sum of two Armstrong numbers is usually not an Armstrong number.
                     âŒ For example, 153 + 370 = 523,   5^3+2^3+3^3 =125+8+27 =160 !=523
Step-by-Step Logic to Check Armstrong Number :
                                - Take a number â†’ e.g. 153
                                - Count how many digits it has â†’ 3
                                - Extract each digit one by one
                                - Raise each digit to the power of total digits
                                - Add them together
                                - Compare the sum with the original number
                                                                 - If equal â†’ âœ… Armstrong
                                                                 - Else â†’ âŒ Not Armstrong


(4) check if a number is palindrome ?
ğŸ‘‰ Short Definition:
A palindrome number is a number that remains the same when its digits are reversed.
Example :
        121 â†’ reverse is 121 â†’ same â†’ Palindrome  
        123 â†’ reverse is 321 â†’ not same â†’ Not Palindrome
ğŸŒŸ Properties of Palindrome Numbers :
      - All single-digit numbers (0â€“9) are palindromes.
                ğŸ‘‰ Because reversing them gives the same number.
      - A palindrome number reads the same both ways.
                Example: 1221 â†’ same from left and right.
      - Palindromes can also appear in strings (like â€œmadamâ€, â€œlevelâ€) â€” not only in numbers.
Step-by-Step Logic to Check Palindrome Number :
Letâ€™s take an example â†’ 121
Step 1ï¸âƒ£
  - Take the number and store it â†’ original_num = 121
Step 2ï¸âƒ£
  - Initialize reversed_num = 0
Step 3ï¸âƒ£
    - Extract the last digit using num % 10
                       â†’ Add it to reversed_num after multiplying by 10
                       â†’ Remove the last digit from num using num = num / 10
Step 4ï¸âƒ£
    - Repeat this until the number becomes 0.
Step 5ï¸âƒ£
    - Compare:
             if (original_num == reversed_num)
            âœ… Palindrome
            else
            âŒ Not Palindrome


Q5. print all divisors of a number ?
A divisor of a number n is any number that divides n completely (without leaving a remainder).
Example:
6 â†’ divisors: 1, 2, 3, 6
12 â†’ divisors: 1, 2, 3, 4, 6, 12
36 â†’ divisors: 1, 2, 3, 4, 6, 9, 12, 18, 36
Step-by-Step Logic to Print All Divisors :
Let's take an example â†’ 36
Step 1ï¸âƒ£
   - Take the number â†’ num = 36
Step 2ï¸âƒ£
   - use for loop from i=1 to i<=sqrt(num);
 Step 3ï¸âƒ£
   - check divisor like if(num % i ==0 ) then print i and other num like num/i also print if (i != num/i) sop(num/i).


Q6. Check if a Number is prime or not ?
A prime number is a number greater than 1 that has exactly two divisors: 1 and itself.
Properties of Prime Numbers:
   - Greater than 1:
          - Prime numbers are always greater than 1.
          - 0 and 1 are not prime.
Only two divisors:
          - A prime number can only be divided evenly by 1 and itself.
          - Example: 5 â†’ divisors: 1, 5
Cannot be negative:
          - Prime numbers are always positive integers.
The smallest prime number:
          - 2 is the smallest prime and the only even prime number.
Odd primes:
          - Except 2, all other prime numbers are odd.
          - Example: 3, 5, 7, 11â€¦
Step-by-Step Logic to Check Prime Number :
Let's take an example â†’ 29
Step 1ï¸âƒ£
  - Take the number â†’ num = 29
Step 2ï¸âƒ£
  - If num <= 1 â†’ Not prime (because prime numbers are > 1)
Step 3ï¸âƒ£
  - Initialize a flag â†’ isPrime = true (assume itâ€™s prime)
Step 4ï¸âƒ£
  - Loop from i = 2 to i <= âˆšnum
            - Why âˆšnum? â†’ If a number has a factor greater than âˆšnum, it must also have a factor smaller than âˆšnum.
            - This makes the check faster.
Step 5ï¸âƒ£
In each iteration, check:  if (num % i == 0) â†’ num is not prime â†’ set isPrime = false â†’ break the loop
Step 6ï¸âƒ£
After the loop, check the flag:
       - isPrime == true â†’ âœ… Prime Number
       - isPrime == false â†’ âŒ Not Prime


Q7. ğŸ§® Sieve of Eratosthenes (à¤-à¤°à¤¾-à¤Ÿà¥‰à¤¸-à¤¥-à¤¨à¥€à¤œà¤¼) FOR 'PRIME' NUMBER?
The Sieve of Eratosthenes is an easy and fast method to find all prime numbers up to a given number n. Instead of checking each number one by one, 
we cross out (remove) all multiples of each prime number.
Example:  Find all prime numbers up to 30.
Start with numbers:  2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 30
1ï¸âƒ£ First prime is 2.
          â†’ Cross out all multiples of 2: 4, 6, 8, 10, 12, ...
2ï¸âƒ£ Next unmarked number is 3.
          â†’ Cross out all multiples of 3: 6, 9, 12, 15, ...
3ï¸âƒ£ Next is 5.
          â†’ Cross out multiples of 5: 10, 15, 20, 25, ...
4ï¸âƒ£ Continue this until âˆšn.
          â†’ All numbers that are not crossed out are prime numbers âœ…
Step-by-Step Logic to Implement
Letâ€™s say we want all prime numbers up to n = 30.
Step 1ï¸âƒ£
       Create a boolean array isPrime[n+1] and fill all entries as true in array using (Arrays.fill(arr, true    -> built-in function).
Step 2ï¸âƒ£
       Mark index[0] and index[1] as false because 0 and 1 are not prime.
Step 3ï¸âƒ£
       Start from i = 2 (assume first prime number). i<=num
Step 4ï¸âƒ£
      If index[i] == true, then mark all multiples of i (like i*i, i*i+i, i*i+2*i, â€¦ up to n) as false. use j = i + i (phla factor pick) ; j<=num; j= j+i;
Step 5ï¸âƒ£
      After the loop ends, all indexes that are still true in the array are prime numbers. for that use loop from i=2; i<=num;


Q8. HCF / GCD â€” Highest Common Factor / Greatest Common Divisor ?
Defination :
- HCF or GCD means the largest same divisor of two or more numbers.that means no remainder is left.
ğŸ’¡ Example:  For numbers 12 and 18:
                       - The numbers that divide 12 are â†’ 1, 2, 3, 4, 6, 12
                       - The numbers that divide 18 are â†’ 1, 2, 3, 6, 9, 18
                       - ğŸ‘‰ Common numbers = 1, 2, 3, 6
                       - ğŸ‘‰ Highest common number = 6
                       - âœ… So, HCF (or GCD) of 12 and 18 is 6.
Follow-up Question :
Wrtie code for finding GCD of 24 and 36 there are two numbers?
STEPS FOR NORMAL APPROACH :
---------------------------
STEP-1:
- find Min(num1,num2) from both num.
STEP-2:
- start loop i=1 to i<=min
STEP-3:
- check both num1 % i == 0 && num2 % i ==0 if yes then update ans=i;


Q9. ğŸ§® Euclidean (à¤¯à¥‚à¤•-à¤²à¥€-à¤¡à¤¿à¤¯à¤¨) Algorithm For FINDING 'GCD' ?
The Euclidean Algorithm is an easy way to find the GCD (Greatest Common Divisor) of two numbers.
    - Subtract or divide the smaller number from the bigger number again and again.
    - if any number num1 or num2 becomes 0 then other number is GCD. 
Two ways to find GCD using the Euclidean Algorithm
ğŸ”¸ 1. Subtraction Method (old/original form)
    - Subtract the smaller number from the bigger one and other number is same repeatedly.
    - Stop if any number num1 or num2 becomes 0 then other number is GCD.
Example:
Find GCD of 60 and 48
60 âˆ’ 48 = 12
48 âˆ’ 12 = 36
36 âˆ’ 12 = 24
24 âˆ’ 12 = 12
âœ… When both become 12 â†’ GCD = 12
STEPS TO IMPLEMENT :
STEP-1 :
- take two number like num1 = 24, num2=36
STEP-2 :
- due to repeated work use loop like while( num1 !=0 && num2 !=0), here if anyone become 0 then loop will break.
STEP-3 :
- now check which one is greate if(num1 > num2 ) then do substraction from num1-num2 else vise versa
STEP-4 :
- after loop completation check (num1==0) return num2 which number is non-zero print that one.

ğŸ”¸ 2. Division Method (modern and faster form)
STEPS TO IMPLEMENT :
STEP-1 :
- take two number like num1 = 24, num2=36
STEP-2 :
- due to repeated work use loop like while( num1 !=0 && num2 !=0), here if anyone become 0 then loop will break.
STEP-3 :
- now check which one is greate if(num1 > num2 ) then do modulo from num1=num1%num2 else vise versa
STEP-4 :
- after loop completation check (num1==0) return num2 which number is non-zero print that one.
Example:
Find GCD of 60 and 48
1ï¸âƒ£ 60 Ã· 48 â†’ remainder 12
2ï¸âƒ£ 48 Ã· 12 â†’ remainder 0
âœ… GCD = 12

Q10. LCM / Least Common Multiple (or Smallest Common Multiple)
Easy Definition:
  - ğŸ‘‰ Matlab do (4,6) ya zyada numbers(4,6,9..) ke aise sabse chhote number (36) ko LCM bolte hain jo sabhi numbers (4,6,9) se completely divide (exactly divide) ho jaye.
ğŸ’¡ Example:  For numbers 4 and 6:
                       - Multiples of 4 â†’ 4, 8, 12, 16, 20, 24, ...
                       - Multiples of 6 â†’ 6, 12, 18, 24, 30, ...
                       - ğŸ‘‰ Common multiples = 12, 24, ...
                       - ğŸ‘‰ Smallest common multiple = 12
                       - âœ… So, LCM of 4 and 6 is 12.
STEPS :
      -> find GCD first,
      -> do n1 * n2 / gcd. you will find the result.

Note:- Relationships between GCD and LCM ?
GCDÃ—LCM=ProductÂ ofÂ theÂ numbers
ğŸ”¹ Example:  Letâ€™s take a = 12 and b = 18
GCD(12, 18) = 6
LCM(12, 18) = 36
Now check the relationship:
ğŸ‘‰ 6 Ã— 36 = 216
ğŸ‘‰ 12 Ã— 18 = 216 âœ…


Q11. Lcm of two numbers if you already know GCD of two numbers ?
Formula :
if a and b are two numbers, then lcm =n1 * n2 / gcd.


Q12. ğŸ§® What is Modular Arithmetic?
Modular Arithmetic is math with remainders.
When we divide a number by another number, the remainder is the result in modular arithmetic.
We write it as:
ğŸ‘‰ a mod m â†’ means remainder when a is divided by m
ğŸ”¹ Example:
10 mod 3 = 1
(because 10 Ã· 3 = 3 remainder 1)
15 mod 5 = 0
(because 15 Ã· 5 = 3 remainder 0)
ğŸ§© Some Useful Rules (in easy words) :
| Rule                                          | Meaning (in simple words)                                                              |
| --------------------------------------------- | -------------------------------------------------------------------------------------- |
| (a + b) mod m = ((a mod m) + (b mod m)) mod m | You can take remainders first, then add                                                | Note:- modulo limit will be given like,1000 (10^3)
| (a âˆ’ b) mod m = ((a mod m) âˆ’ (b mod m)) mod m | You can take remainders first, then subtract                                           |
| (a Ã— b) mod m = ((a mod m) Ã— (b mod m)) mod m | You can take remainders first, then multiply                                           |
| (a % m) % m = a % m                           | Taking mod twice doesnâ€™t change the answer                                             |
| m % m = 0 âœ…                                   | Any number divided by itself gives remainder 0 (your note had 1, but correct is **0**) |

Note:- ğŸ§  Modular Multiplicative Inverse :
The modular inverse of a number a is another number aâ»Â¹ such that:
                                                          (aÃ—a^âˆ’1)modm=1
That means â€”
when you multiply a and its inverse, and take the remainder with m,
you get 1.
ğŸ”¹ Example:
Letâ€™s find the modular inverse of 3 mod 11.
We need a number x such that
(3 Ã— x) mod 11 = 1
Try values of x:
3Ã—4 = 12 â†’ 12 mod 11 = 1 âœ…
So the modular inverse of 3 mod 11 is 4



Q12. Factorial of a Number ?
  - Factorial means multiplying a number by all the whole numbers less than it down to 1.
  - It is shown using a â€œ!â€ (exclamation mark).
ğŸ’¡ Example:
For number 5,
ğŸ‘‰ 5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120
More examples:
4! = 4 Ã— 3 Ã— 2 Ã— 1 = 24
3! = 3 Ã— 2 Ã— 1 = 6
1! = 1 (by rule)
0! = 1 (special rule)
ğŸ’¡ Rule of Factorial:  n!=nÃ—(nâˆ’1)!
ğŸ§© Example using the rule:
Letâ€™s take 5!
5!=5Ã—(5âˆ’1)!   5!=5Ã—4!
Now, 4!=4Ã—3Ã—2Ã—1=24
So, 5!=5Ã—24=120âœ…
ğŸ“˜ Special Rules:
1! = 1
0! = 1 (by definition â€” special mathematical rule)

                                                                                 ___________________________________________START_________________________________________________
Q13. Find trailing zeros in a factorial ?             
             
suppose you are given a number '456700442000' can you calculate the number of zeros in it? Yes, you can easily, 
simply use the extraction and reduction method to extract the digits from the end and check if it is a non zero number.
   1. if it is 0, add the count.
   2. if it is non zero, break the loop.
count is your answer, simple!
But when you are asked to find trailing zeros from factorial of a number. There is a high chance that this number might exceed 
the range of Integer/long and you can't store it! So, if you can't store it, how will you find it's trailing zeros? let's understand, 
what brings zero at the end of a number!
   1. Suppose the number is '68' lets find its factors-> 68 = 2*2*17
   2. Suppose the number is '70' lets find its factors-> 70 = 2*5*7
   3. Suppose the number is '680' 680 = 2*2*2*5*17
   4. Suppose the number is '6800' 6800 = 2*2*2*2*5*5*17
did you observe anything?
yes,
68 has zero pairs of 2 and 5. 
70 has one pair of 2 and 5.
680 has one pair of 2 and 5. 
6800 has two pair of 2 and 5.
Bs ho gya question solve! find all the pairs of 2 and 5.
But but but... lets come back to factorial.
!3 = 321 !7 = 7654321 (1 pair of 5,2) !12 = 12111098765432*1 (2 pair of 5,2)
Observations->
We can see that 2 will be there for every number greater than 1. (obviously) so be smart and calculate only 5's because 
count of '2s' will always be greater than equal to count of '5s'.
5 repeats in interval of 5. ex -> 5, 10, 15, and so on
Therefore, floor of (N/5) will give the correct answer! But wait what about squares, cubes and so on? Like..
'5' has one '5'
'10' has one '5' (5*2)
'15' has one '5'
'20' has one '5'
'25' has two '5' (5*5, square) ....
'125' has three '5' (555, cube).
conclusion->
To handle the special condition we can say.
for square case-> N/25 + N/5
for cube case-> N/125 + N/25 + N/5
and so on...
Example -> !30 = 302928..2524*..20...1514*..109*..5*4..*1 (7 pairs of 5,2)

Since 30 is greater than 25, -> 30 / 5 + 30 / 25 -> floor (6) + floor(1.2) -> 6 + 1 -> 7

STEPS:
 1. doubl res = 0;
 2. for(int i = 5; i<=num; i= i * i){ res = res+Math.floor(num/i)}
 3. return res;
















  
