(1) Count the Digits of a number lets say number is : 4567 ?
Steps to solve :
           - Take a number → say num = 4567
           - Initialize a counter → count = 0
           - Repeat while num > 0:
                    - Remove the last digit using num = num / 10
                    - Increase the counter → count++
           - When the loop finishes, count will have the total number of digits.
Note:- to handle specail condition like 0 for input : use if condition and directly print 1 . 


(2) Check if a Number is armstrong or not. ?
👉 Short Definition:
A number is called an Armstrong number if the sum of each of its digits raised to the power of total digits equals the number itself.
Example: Let’s take 153
                  → It has 3 digits                 
                  → So we do:  1³ + 5³ + 3³ = 1 + 125 + 27 = 153
🌟 Properties of ArmStrong number :
                   - All single-digit numbers (0–9) are Armstrong numbers.
                       👉 Because for example: 5 = 5¹ ✅
                   - Permutations of an Armstrong number are not always Armstrong
                       ❌ (e.g., 153 is Armstrong but 531 is not!)
                   - Armstrong numbers are not always palindromes.
                     ❌ For example, 153 ≠ 351 , Only a few are plindrome also (like 1, 0, to 9.).
                   - The sum of two Armstrong numbers is usually not an Armstrong number.
                     ❌ For example, 153 + 370 = 523,   5^3+2^3+3^3 =125+8+27 =160 !=523
Step-by-Step Logic to Check Armstrong Number :
                                - Take a number → e.g. 153
                                - Count how many digits it has → 3
                                - Extract each digit one by one
                                - Raise each digit to the power of total digits
                                - Add them together
                                - Compare the sum with the original number
                                                                 - If equal → ✅ Armstrong
                                                                 - Else → ❌ Not Armstrong


(3) check if a number is palindrome ?
👉 Short Definition:
A palindrome number is a number that remains the same when its digits are reversed.
Example :
        121 → reverse is 121 → same → Palindrome  
        123 → reverse is 321 → not same → Not Palindrome
🌟 Properties of Palindrome Numbers :
      - All single-digit numbers (0–9) are palindromes.
                👉 Because reversing them gives the same number.
      - A palindrome number reads the same both ways.
                Example: 1221 → same from left and right.
      - Palindromes can also appear in strings (like “madam”, “level”) — not only in numbers.
Step-by-Step Logic to Check Palindrome Number :
Let’s take an example → 121
Step 1️⃣
  - Take the number and store it → original_num = 121
Step 2️⃣
  - Initialize reversed_num = 0
Step 3️⃣
    - Extract the last digit using num % 10
                       → Add it to reversed_num after multiplying by 10
                       → Remove the last digit from num using num = num / 10
Step 4️⃣
    - Repeat this until the number becomes 0.
Step 5️⃣
    - Compare:
             if (original_num == reversed_num)
            ✅ Palindrome
            else
            ❌ Not Palindrome


Q4. print all divisors of a number ?
A divisor of a number n is any number that divides n completely (without leaving a remainder).
Example:
6 → divisors: 1, 2, 3, 6
12 → divisors: 1, 2, 3, 4, 6, 12
36 → divisors: 1, 2, 3, 4, 6, 9, 12, 18, 36
Step-by-Step Logic to Print All Divisors :
Let's take an example → 36
Step 1️⃣
   - Take the number → num = 36
Step 2️⃣
   - Initialize a counter → counter = 1
 Step 3️⃣
   - Calculate the square root of the number → sqroot = (int) Math.sqrt(num)
Step 4️⃣
   - Start a loop while counter <= sqroot
Step 5️⃣
   - In each iteration, check if num % counter == 0
        - If yes, it means counter is a divisor
        - Also calculate the paired divisor → otherNumber = num / counter
Step 6️⃣
   - Print both divisors:  counter + " , " + otherNumber + " are divisors of " + num
Step 7️⃣
   - Increment the counter → counter++
Step 8️⃣
   - Repeat until counter exceeds sqroot



Q5. Check if a Number is prime or not ?
A prime number is a number greater than 1 that has exactly two divisors: 1 and itself.
Properties of Prime Numbers:
   - Greater than 1:
          - Prime numbers are always greater than 1.
          - 0 and 1 are not prime.
Only two divisors:
          - A prime number can only be divided evenly by 1 and itself.
          - Example: 5 → divisors: 1, 5
Cannot be negative:
          - Prime numbers are always positive integers.
The smallest prime number:
          - 2 is the smallest prime and the only even prime number.
Odd primes:
          - Except 2, all other prime numbers are odd.
          - Example: 3, 5, 7, 11…
Step-by-Step Logic to Check Prime Number :
Let's take an example → 29
Step 1️⃣
  - Take the number → num = 29
Step 2️⃣
  - If num <= 1 → Not prime (because prime numbers are > 1)
Step 3️⃣
  - Initialize a flag → isPrime = true (assume it’s prime)
Step 4️⃣
  - Loop from i = 2 to i <= √num
            - Why √num? → If a number has a factor greater than √num, it must also have a factor smaller than √num.
            - This makes the check faster.
Step 5️⃣
In each iteration, check:  if (num % i == 0) → num is not prime → set isPrime = false → break the loop
Step 6️⃣
After the loop, check the flag:
       - isPrime == true → ✅ Prime Number
       - isPrime == false → ❌ Not Prime


Q6. 🧮 Sieve of Eratosthenes  ?
The Sieve of Eratosthenes is an easy and fast method to find all prime numbers up to a given number n. Instead of checking each number one by one, 
we cross out (remove) all multiples of each prime number.
Example:  Find all prime numbers up to 30.
Start with numbers:  2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 30
1️⃣ First prime is 2.
          → Cross out all multiples of 2: 4, 6, 8, 10, 12, ...
2️⃣ Next unmarked number is 3.
          → Cross out all multiples of 3: 6, 9, 12, 15, ...
3️⃣ Next is 5.
          → Cross out multiples of 5: 10, 15, 20, 25, ...
4️⃣ Continue this until √n.
          → All numbers that are not crossed out are prime numbers ✅
Step-by-Step Logic to Implement
Let’s say we want all prime numbers up to n = 30.
Step 1️⃣
       Create a boolean array isPrime[n+1] and fill all entries as true in array using (Arrays.fill(arr, true    -> built-in function).
Step 2️⃣
       Mark index[0] and index[1] as false because 0 and 1 are not prime.
Step 3️⃣
       Start from i = 2 (the first prime number).
Step 4️⃣
      If index[i] == true, then mark all multiples of i (like i*i, i*i+i, i*i+2*i, … up to n) as false.
Step 5️⃣
      Repeat Step 4 for all i from 2 to √n.
Step 6️⃣
      After the loop ends, all indexes that are still true in the array are prime numbers.


Q7. HCF / GCD — Highest Common Factor / Greatest Common Divisor ?
Defination :
- HCF or GCD means the largest same divisor of two or more numbers.that means no remainder is left.
💡 Example:  For numbers 12 and 18:
                       - The numbers that divide 12 are → 1, 2, 3, 4, 6, 12
                       - The numbers that divide 18 are → 1, 2, 3, 6, 9, 18
                       - 👉 Common numbers = 1, 2, 3, 6
                       - 👉 Highest common number = 6
                       - ✅ So, HCF (or GCD) of 12 and 18 is 6.
Follow-up Question :
Wrtie code for finding GCD of 24 and 36 there are two numbers?


Q8. LCM / Least Common Multiple (or Smallest Common Multiple)
Easy Definition:
  - LCM means the smallest same multiple of two or more numbers. (with no remainder).
💡 Example:  For numbers 4 and 6:
                       - Multiples of 4 → 4, 8, 12, 16, 20, 24, ...
                       - Multiples of 6 → 6, 12, 18, 24, 30, ...
                       - 👉 Common multiples = 12, 24, ...
                       - 👉 Smallest common multiple = 12
                       - ✅ So, LCM of 4 and 6 is 12.
Follow-up Question :
Wrtie code for finding GCD of 24 and 36 there are two numbers?

Note:- Relationships between GCD and LCM ?
GCD×LCM=Product of the numbers
🔹 Example:  Let’s take a = 12 and b = 18
GCD(12, 18) = 6
LCM(12, 18) = 36
Now check the relationship:
👉 6 × 36 = 216
👉 12 × 18 = 216 ✅


Q9. 🧮 Euclidean Algorithm For Finding GCD ?
The Euclidean Algorithm is an easy way to find the GCD (Greatest Common Divisor) of two numbers.
    - Subtract or divide the smaller number from the bigger number again and again.
    - When the remainder becomes 0, the last non-zero remainder is the GCD.
Two ways to find GCD using the Euclidean Algorithm
🔸 1. Subtraction Method (old/original form)
    - Subtract the smaller number from the bigger one repeatedly
    - Stop when both numbers become equal — that number is the GCD.
Example:
Find GCD of 60 and 48
60 − 48 = 12
48 − 12 = 36
36 − 12 = 24
24 − 12 = 12
✅ When both become 12 → GCD = 12
🔸 2. Division Method (modern and faster form)
    - Divide the bigger number by the smaller one
    - Take the remainder
    - Replace the bigger number with the smaller one, and the smaller one with the remainder
    - Repeat until remainder = 0
    - The last non-zero remainder is the GCD
Example:
Find GCD of 60 and 48
1️⃣ 60 ÷ 48 → remainder 12
2️⃣ 48 ÷ 12 → remainder 0
✅ GCD = 12


Q10. Lcm of two numbers if you already know GCD of two numbers ?
Formula :
if a and b are two numbers, then lcm(a,b) * gcd(a,b) = a*b


Q11. 🧮 What is Modular Arithmetic?
Modular Arithmetic is math with remainders.
When we divide a number by another number, the remainder is the result in modular arithmetic.
We write it as:
👉 a mod m → means remainder when a is divided by m
🔹 Example:
10 mod 3 = 1
(because 10 ÷ 3 = 3 remainder 1)
15 mod 5 = 0
(because 15 ÷ 5 = 3 remainder 0)
🧩 Some Useful Rules (in easy words) :
| Rule                                          | Meaning (in simple words)                                                              |
| --------------------------------------------- | -------------------------------------------------------------------------------------- |
| (a + b) mod m = ((a mod m) + (b mod m)) mod m | You can take remainders first, then add                                                |
| (a − b) mod m = ((a mod m) − (b mod m)) mod m | You can take remainders first, then subtract                                           |
| (a × b) mod m = ((a mod m) × (b mod m)) mod m | You can take remainders first, then multiply                                           |
| (a % m) % m = a % m                           | Taking mod twice doesn’t change the answer                                             |
| m % m = 0 ✅                                   | Any number divided by itself gives remainder 0 (your note had 1, but correct is **0**) |

Note:- 🧠 Modular Multiplicative Inverse :
The modular inverse of a number a is another number a⁻¹ such that:
                                                          (a×a^−1)modm=1
That means —
when you multiply a and its inverse, and take the remainder with m,
you get 1.
🔹 Example:
Let’s find the modular inverse of 3 mod 11.
We need a number x such that
(3 × x) mod 11 = 1
Try values of x:
3×4 = 12 → 12 mod 11 = 1 ✅
So the modular inverse of 3 mod 11 is 4



Q12. Factorial of a Number ?
  - Factorial means multiplying a number by all the whole numbers less than it down to 1.
  - It is shown using a “!” (exclamation mark).
💡 Example:
For number 5,
👉 5! = 5 × 4 × 3 × 2 × 1 = 120
More examples:
4! = 4 × 3 × 2 × 1 = 24
3! = 3 × 2 × 1 = 6
1! = 1 (by rule)
0! = 1 (special rule)
💡 Rule of Factorial:  n!=n×(n−1)!
🧩 Example using the rule:
Let’s take 5!
5!=5×(5−1)!   5!=5×4!
Now, 4!=4×3×2×1=24
So, 5!=5×24=120✅
📘 Special Rules:
1! = 1
0! = 1 (by definition — special mathematical rule)


Q13. Find trailing zeros in a factorial ?
             
 a. How many zeros are at the end of N! ?
Trailing zeros in a number come from factors of 10. Each 10 = 2 × 5.
So every pair of a 2 and a 5 in the prime factors of N! contributes one trailing zero.

 b. Key insight (why we only count 5s)
    In N! = 1 × 2 × 3 × ... × N, there are far more factors of 2 than 5 (even numbers give lots of 2s).
    Therefore the limiting factor is how many 5s appear in the prime factorization of N!.
    So: number of trailing zeros = number of times 5 divides N! (i.e., count of factors 5).

c. Counting 5s (the formula) :
Formula :  zeros=⌊N/5​⌋+⌊N/5^2​⌋+⌊N/5^3​⌋+...
Stop when 5^k  > N
Explanation in words:
⌊N/5⌋ counts numbers divisible by 5 (each contributes at least one 5).
⌊N/25⌋ counts numbers divisible by 25 (they contribute an extra 5).
⌊N/125⌋  counts numbers divisible by 125 (they contribute yet another 5), and so on.

 d. Step-by-step method (beginner steps)
     - Take your input N.
     - Set count = 0.
     - Set p = 5.
     - While p <= N:
            - Add floor(N / p) to count.
            Multiply p by 5 (next power of 5).
When loop ends, count is the number of trailing zeros in N!.

Example 1 — small (N = 30) — show arithmetic clearly
Compute:
     - ⌊30/5⌋=6 (numbers: 5,10,15,20,25,30)
     - ⌊30/25⌋=1 (25 gives an extra 5)
     - ⌊30/125⌋=0 stop here
Sum = 6+1=7
So 30! has 7 trailing zeros. (Matches your example.)

Example 2 — large (N = 456700442000) — show first divisions
We use the same process. I’ll show the divisions step-by-step (floor results):
⌊N/5⌋=91,340,088,400
⌊N/25⌋=18,268,017,680
⌊N/125⌋=3,653,603,536
⌊N/625⌋=730,720,707
⌊N/3125⌋=146,144,141
⌊N/15625⌋=29,228,828
⌊N/78125⌋=5,845,765
⌊N/390625⌋=1,169,153
⌊N/1,953,125⌋=233,830
⌊N/9,765,625⌋=46,766
⌊N/48,828,125⌋=9,353
⌊N/244,140,625⌋=1,870
⌊N/1,220,703,125⌋=374
⌊N/6,103,515,625⌋=74
⌊N/30,517,578,125⌋=14
⌊N/152,587,890,625⌋=2
Next power =762,939,453,125>𝑁 so stop.
Add them all up: 114,175,110,493
So 456,700,442,000! has 114,175,110,493 trailing zeros.


















  
