TABLE OF BINARY NUMBER :
| Decimal | Binary |
| ------- | ------ |
| 1       | 0001   |
| 2       | 0010   |
| 3       | 0011   |
| 4       | 0100   |
| 5       | 0101   |
| 6       | 0110   |
| 7       | 0111   |
| 8       | 1000   |
| 9       | 1001   |
| 10      | 1010   |

Q1. What is Bit (Binary Digit ) ?
 - A bit is the smallest unit/box of data in a computer.
 - It can have only two possible values â€” 0 or 1.
ğŸ’¡ Think of it like a simple switch:
0 means OFF
1 means ON
Computers use bits to store and process all kinds of information â€” numbers, letters, images, and even videos â€” by combining many bits together.
Example:
1 bit â†’ can represent 2 values â†’ 0 or 1
2 bits â†’ can represent 4 values â†’ 00, 01, 10, 11
3 bits â†’ can represent 8 values â†’ 000 , 001 , 010 , 011 , 100 , 101, 110 , 111    

Note:-
    - if there is n bits so The maximum number you can represent starting from 0  to  2^â¿ âˆ’ 1
    - If you have n bits, they can form 2â¿ unique combinations of 0s and 1s.
    - ğŸ‘‰ Each combination is one distinct pattern that represents one value.
    - Example :
               - 4 bits = a group of 4 binary digits (like 0000 or 1101).
               - 5 bits = a group of 5 binary digits (like 00000 or 10110).

ğŸ§  1ï¸âƒ£ Bit Positions â€“ MSB and LSB :
| Term    | Full Form             | Meaning                               | Example (for 8-bit number `10110100`) |
| ------- | --------------------- | ------------------------------------- | ------------------------------------- |
| **MSB** | Most Significant Bit  | Leftmost bit (highest value position) | **1**0110100                          |
| **LSB** | Least Significant Bit | Rightmost bit (lowest value position) | 1011010**0**                          |

structure :
ğŸ‘‰ MSB -------- LSB
Example:
1 0 1 1 0 1 0 0
â¬†ï¸ MSBâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ¬‡ï¸ LSB

ğŸ§© 2ï¸âƒ£ Signed vs Unsigned Numbers :
| Type                | Sign Information                                  | MSB Role                                        | Value Range Formula   | Example (4 bits)       |
| ------------------- | ------------------------------------------------- | ----------------------------------------------- | --------------------- | ---------------------- |
| **Unsigned Number** | âŒ No sign (only positive values)                  | MSB is just another value bit                   | [0, (2â¿ âˆ’ 1)]         | 0 to 15 (0000 to 1111) |
| **Signed Number**   | âœ… MSB shows the sign (0 = positive, 1 = negative) | MSB denotes sign, remaining bits show magnitude | [âˆ’(2â¿â»Â¹ âˆ’ 1), (2â¿â»Â¹ âˆ’ 1)] | âˆ’7 to +7           |
Note:-
2â€™s complement allows one extra negative number (âˆ’8) compared to positive (+7) so formula will be :
[âˆ’(2â¿â»Â¹), (2â¿â»Â¹ âˆ’ 1)]


Q2. ğŸ§  Bit Addition (Binary Addition) ?
In binary, we only have two digits:
ğŸ‘‰ 0 and 1
So, when we add bits, we follow four simple rules ğŸ‘‡
| Bit 1 | Bit 2 | Sum | Carry                      |
| ----- | ----- | --- | -------------------------- |
| 0 + 0 | â†’     | 0   | 0                          |
| 0 + 1 | â†’     | 1   | 0                          |
| 1 + 0 | â†’     | 1   | 0                          |
| 1 + 1 | â†’     | 0   | 1 (carry 1 to next column) |

Binary confusion without 2â€™s complement :
                    - Suppose we try to store âˆ’1 and +5 in binary without a proper system.
                    - If you just use sign bit only (0 = +, 1 = âˆ’) and remaining bits for value:
                    - Example 3-bit numbers:     
                                 -    +5 â†’ ??? (3 bits can't store 5 properly, max is 3 bits â†’ 0 to 7)
                    - So letâ€™s use 4 bits for simplicity:
                                 -    +5 â†’ 0101
                                 -    âˆ’1 â†’ ???  (if we just invert bits: 1110? or 101?) â†’ confusion arises
                    - You see, without a systematic method, âˆ’1 could look similar to another positive number.
                    - Computers cannot directly do addition/subtraction if negative numbers are not in a consistent format.
here, How 2â€™s complement solves this :

ğŸ§  1ï¸âƒ£ What is 1â€™s Complement and 2â€™s Complement?
These are methods to represent negative numbers in binary.
ğŸ”¹ 1â€™s Complement
         - Take the binary of the positive number.
         - Invert all bits (0 â†’ 1, 1 â†’ 0).
         - The result is the negative number.
         - Example (4 bits):
                       -    +5 â†’ 0101
                       -   âˆ’5 (1â€™s complement) â†’ invert all bits â†’ 1010
         - Problem with 1â€™s complement:
                            - There are two representations for 0: 0000 (+0) and 1111 (âˆ’0) â†’ confusing
ğŸ”¹ 2â€™s Complement
         - Take the binary of the positive number.
         - Invert all bits â†’ then add 1 to the result.
         - This is now the negative number.
         - Example (4 bits):
                 -     +5 â†’ 0101
                 -     Step 1: invert all bits â†’ 1010
                 -     Step 2: add 1 â†’ 1010 + 1 = 1011
                 -     So âˆ’5 = 1011
Advantages of 2â€™s complement:
         - Only one 0 (0000)
         - Addition and subtraction work naturally
         - Most computers use 2â€™s compleme


Q3. Bit Subtraction
Step 1: Write both numbers in binary
        - Make sure both numbers have the same number of bits (add leading zeros if needed).
        - Example: Subtract 5 âˆ’ 3 using 4-bit binary :
                                            num1 = 5 â†’ 0101
                                            num2 = 3 â†’ 0011
Step 2: Find 2â€™s complement of num2 :
        - Invert all bits (0 â†’ 1, 1 â†’ 0) â†’ this is 1â€™s complement
        - Add 1 to the result â†’ this is 2â€™s complement
        - Example :
                  num2 = 3 â†’ 0011
                  Step 1: Invert bits â†’ 1100
                  Step 2: Add 1 â†’ 1100 + 1 = 1101
Step 3: Add num1 and 2â€™s complement of num2 :
               Example :
                      0101  (num1 = 5)
                    + 1101  (2â€™s complement of num2 = 3)
                      -------
                      10010
Step 4: Handle carry (if fixed number of bits) :
          - We are using 4-bit binary, so discard the 5th bit (overflow).
Step 5: Convert binary result to decimal :
          0010 â†’ 2 âœ… correct


Q4. Bitwise Operators  ?

1ï¸âƒ£ AND (&)
Definition: 
Compares each bit of two numbers and returns 1 if both bits are 1, otherwise 0.
Example : 
5 & 3 â†’ 0101 & 0011 = 0001 â†’ 1

2ï¸âƒ£ OR (|)
Definition:
Compares each bit of two numbers and returns 1 if any one of the bits is 1, otherwise 0.
Example :
5 | 3 â†’ 0101 | 0011 = 0111 â†’ 7

3ï¸âƒ£ XOR (^)
Definition:
Compares each bit and returns 1 if bits are different, otherwise 0.
Example:
5 ^ 3 â†’ 0101 ^ 0011 = 0110 â†’ 6

4ï¸âƒ£ NOT (~)
Definition: 
Flips all bits (0 â†’ 1, 1 â†’ 0).
Example :
~5 â†’ ~0101 = 1010 â†’ -6 (in 2â€™s complement for signed numbers)

5ï¸âƒ£ Left Shift (<<)
Definition:
Shifts all bits to the left by n positions, filling with 0s on the right.
Example:
5 << 1 â†’ 0101 << 1 = 1010 â†’ 10

6ï¸âƒ£ Right Shift (>>)
Definition: 
Shifts all bits to the right by n positions.
  - For signed numbers, MSB (sign) is copied.
  - Example:
5 >> 1 â†’ 0101 >> 1 = 0010 â†’ 2


7ï¸âƒ£ Unsigned Right Shift (>>>) (Java specific)
Definition:
Shifts bits to the right, filling 0s on the left, ignoring sign.
Example:
-5 >>> 1 â†’ fills left bits with 0 â†’ large positive number















