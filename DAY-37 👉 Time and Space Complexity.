⭐ What is Algorithm Complexity?
How fast an algorithm runs and how much memory it uses when input size becomes large.
Well, an algorithm is measured based on :
                         - Time Complexity → how much time it takes.
                         - Space Complexity → how much memory (RAM) it uses.
⭐ Why is Time Complexity important?
Because when input becomes big (like 10⁴ or 10⁶), slow algorithm becomes too slow, fast algorithm works instantly.
Example:
| Algorithm     | Time Complexity | Input = 10⁴ | Steps         |
| ------------- | --------------- | ----------- | ------------- |
| Linear Search | O(N)            | 10,000      | 10,000 checks |
| Binary Search | O(log N)        | log(10,000) | 13 checks     |
✅ so here, Binary search is 700 times faster.

⭐ What is used to represent the complexity of Algorithms? 
Asymptotic Notation 
   a. What is Asymptotic Notation?
    it is a standard way of writing time complexity. Since we cannot count exact steps, we write approximate growth using: 
            1️⃣ Big-O (Upper bound) :
                 Upper bound tells the maximum time an algorithm can take in the worst case. suppose your algorithm worst to worst it will take 10 steps it means your answer can be in one step,2 step but not in 11 steps
                        - Maximum time taken.
                        - Worst case.
                        - Example: O(N) → in worst case, algorithm takes N steps.
            2️⃣ Big-Omega (Lower bound) :
                 lower bound tells the minimum time an algorithm will take in the best case. suppose your algoritham If your algorithm needs at least 2 steps,then it might take 2 steps, 10 steps, or 100 steps…but never finish in 1 step.
                        - Minimum time taken.
                        - Best case.
                        - Example: Ω(1) → best case runs in constant time.
            3️⃣ Big-Theta (Tight bound) :
                        - Exact/average performance.
                        - Between best and worst.
                        - Example: Θ(N log N) → average case complexity.
⭐ What is Time Complexity?
Time Complexity tells us , the rate of increase in time with an increase in the size of input. It does not mean real time like seconds or minutes because:
  - Same code runs faster on one computer,
  - And slower on another.
So we measure time using asymptotic notation, not actual seconds.
⭐ Rules to Analyse Time Complexity :
- Always check worst case.
              Worst case = Big-O.
- Ignore constants.
              O(2N) → O(N)
- Ignore smaller terms.
              O(N + N²) → O(N²)
- We use Big-O notation because it shows the maximum time taken by the algorithm.
- For loops:
            Nested loop → Outer * Inner   , Example: 2 loops → O(N²)
- If input is divided each time → log
            Divide by 2 → log₂ N
            Divide by 3 → log₃ N
            (Binary search example)
Time Complexity Growth Order :
O(1) > O(log n) > O(√n) > O(n) > O(n log n) > O(n²) > O(n³) > … > O(2ⁿ) > O(n!)   
✔ Left = Faster and
✔ Right = Slower


⭐ What is Space Complexity?
Space Complexity = Input size + Extra space used by algorithm.
- Input space = space taken by given data
- Auxiliary space = extra space (new arrays, variables, lists)
Important rule:
❗ Do not change (modify) the input array unless allowed. Interviewers don’t like that.
If you modify input,
→ convert it back before finishing
→ still better to avoid.


The Big O cheatsheet by Eric is available at https://www.bigocheatsheet.com/.

⭐ Analysis of time complexity :
---------------------------------
Note:-
-> if there is no loop , no recursion, no repetation, no repetation function call then time complexity will be O(1) means constant time.

LOOP ANALYSIS :
----------------
Q1.  for (int i =0; i<n; i++) { something..} 
Ans: here loop will run 0 to n-1 so worst case time complexity will be O(n-1) since we avoid constant so final time complexity will be O(n).

Q2. for(int i=n; i>0; i--){ something..}
Ans: here also loop will run n to 0 in reverse but it will run unless n become equals to 0 so either loop is going to run 0 to O(n-1) or n to 0 time complexity will be O(n).

Q3. for (int i =0; i<n; i+=5) { something..}
Ans: here it will run n/5 because incrementing +5 in each step so if n = 12 so in each step divide 12/5= 2... so we consider ceil value so loop will run 0,5,10 means 3 times so tc will be O(n/5) which is equals to O(n)

Q4. for (int i =0; i<n; i++){
     for (int j =0; j<m; j++){ something..}}
Ans : first loop will run O(n-1) and inner loop will run O(m-1) 
     ex- suppose n = 6; and m = 3;
         so,     i            j
                 0            3 times
                 1            3 times
                 2            3 times
                 3            3 times
                 4            3 times
                 5            3 times
                      total = 18 times
so we can say time complexity will be O(n-1) * O(m-1) but we ignore constant so O(n*m) 
- if there will be n instead of m so time complexity should have O(n2) except incrementing both loop by +1.

Q5.  for (int i =0; i<n; i++){
     for (int j =0; j<i; j++){ something..}}
Ans : suppose n = 5;
         so,     i            j
                 0            0 times
                 1            1 times
                 2            2 times
                 3            3 times
                 4            4 times
now see how many times j is running for i, j like, 0+1+2+3+4 times which is nothing but equivalent to sum of n natural number formula like n(n+1)/2 so
n2/2+n/2 => ignore constant and lower power one so n2 => now we have to take one minus as per our loop so O(n-1)2 => here also ignore constant so final O(n2).

Q6. for (int i =0; i<n; i*=2){statement.}
Ans: it should be infinite loop because 0*2=0 no increment 

Q7. for (int i =1; i<n; i*=2){stmt.}
ex -    n=10     i          increment   nothing but 2^pow
                 1            1              2^0
                 1*2          2              2^1
                 2*2          4              2^2
                 4*2          8              2^3
                                              .
                                              .
                                            2^k >=n   => 2^k=n  =>  k=log₂ n

Q8. for (int i =n; i>=1; i=i/2){stmt.}
ex -    n=10     i            nothing but 2^pow
                 10                10/2^0
                 10/2              10/2^1
                 10/4              10/2^2
                 10/8              10/2^3
                                     .
                                     .
                                    10/2^k =1 here 1 is the first value which will stop   => 2^k=n n here is 10  =>  k=log₂ n

Q9. for (int i =0; i*i<n; i++){stmt.}
Ans:  jab i*i>=n to loop bnd ho jayegi so i^2 >=n    =>  i>=(√n)   => O(√n)

Q10. for (int i =0; i<n; i++){stmt.}
     for (int j =0; j<m; j++){stmt.}
Ans: both seperate so O(n+m)

Q11. int k=0;
     for (int i =1; i<n; i*=2){k++}
     for (int j =1; j<k j*=2){stmt.}
Ans: first loop log₂ n and second should have log₂ k but k in first loop incrementing so instead of k, we writing  O(log₂ (log₂ n)).

Q12. for (int i =0; i<n; i++){
     for (int j =1; j<n; j*=2){stmt.}}
Ans: outer loop O(n) and inner loop log₂ n  so  O(n * log n)   => O(n log n).



                                     







